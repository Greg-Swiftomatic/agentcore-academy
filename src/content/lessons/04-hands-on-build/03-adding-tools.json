{
  "title": "Adding Custom Tools",
  "objectives": [
    "Create custom tools using the @tool decorator",
    "Integrate tools with your agent",
    "Test tool execution locally and in production"
  ],
  "content": "# Adding Custom Tools\n\nA basic agent can chat, but tools make it useful. Let's extend your agent with custom capabilities.\n\n## Your First Tool\n\nAdd a simple tool to get the current time:\n\n```python\nfrom bedrock_agentcore import BedrockAgentCoreApp\nfrom strands import Agent, tool\nfrom datetime import datetime\n\napp = BedrockAgentCoreApp()\n\n@tool\ndef get_current_time() -> str:\n    \"\"\"Get the current date and time.\"\"\"\n    return datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n# Create agent WITH the tool\nagent = Agent(tools=[get_current_time])\n\n@app.entrypoint\ndef invoke(payload):\n    user_message = payload.get(\"prompt\", \"Hello!\")\n    result = agent(user_message)\n    return {\"result\": result.message}\n\nif __name__ == \"__main__\":\n    app.run()\n```\n\nTest it:\n\n```bash\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"prompt\": \"What time is it?\"}'\n```\n\nResponse:\n```json\n{\"result\": \"The current time is 2026-01-01 14:30:45.\"}\n```\n\nThe agent automatically:\n1. Recognized the user wanted to know the time\n2. Called your `get_current_time` tool\n3. Formatted the result into a natural response\n\n## How Tools Work\n\n### The @tool Decorator\n\n```python\n@tool\ndef my_function(param: str) -> str:\n    \"\"\"Description of what this tool does.\"\"\"\n    return result\n```\n\nThe decorator extracts:\n- **Name**: From the function name (`my_function`)\n- **Description**: From the docstring (critical for selection!)\n- **Parameters**: From type hints and docstring\n- **Return type**: From the return annotation\n\n### Tool Selection\n\nThe agent decides when to use your tool based on the description:\n\n```python\n# BAD: Vague description\n@tool\ndef do_thing() -> str:\n    \"\"\"Does a thing.\"\"\"\n    ...\n\n# GOOD: Clear, specific description\n@tool\ndef get_current_time() -> str:\n    \"\"\"Get the current date and time. Use when the user asks\n    what time it is, what today's date is, or anything time-related.\"\"\"\n    ...\n```\n\n## Multiple Tools\n\nAdd a calculator alongside the time tool:\n\n```python\nfrom bedrock_agentcore import BedrockAgentCoreApp\nfrom strands import Agent, tool\nfrom datetime import datetime\nimport math\n\napp = BedrockAgentCoreApp()\n\n@tool\ndef get_current_time() -> str:\n    \"\"\"Get the current date and time.\"\"\"\n    return datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n@tool\ndef calculate(expression: str) -> float:\n    \"\"\"Evaluate a mathematical expression.\n    \n    Args:\n        expression: A math expression like '2 + 2', 'sqrt(16)', or '15 * 7'\n    \n    Returns:\n        The result of the calculation\n    \"\"\"\n    # Safe evaluation - only allow math functions\n    allowed = {k: v for k, v in math.__dict__.items() if not k.startswith(\"_\")}\n    return eval(expression, {\"__builtins__\": {}}, allowed)\n\n# Register both tools\nagent = Agent(tools=[get_current_time, calculate])\n\n@app.entrypoint\ndef invoke(payload):\n    user_message = payload.get(\"prompt\", \"Hello!\")\n    result = agent(user_message)\n    return {\"result\": result.message}\n\nif __name__ == \"__main__\":\n    app.run()\n```\n\nNow test both:\n\n```bash\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"prompt\": \"What time is it, and what is 25 * 4?\"}'\n```\n\nThe agent calls both tools and combines the results:\n```json\n{\"result\": \"It's currently 2026-01-01 14:35:22, and 25 * 4 = 100.\"}\n```\n\n## Tools with Parameters\n\nDocument parameters clearly:\n\n```python\n@tool\ndef convert_temperature(value: float, from_unit: str, to_unit: str) -> float:\n    \"\"\"Convert temperature between Celsius, Fahrenheit, and Kelvin.\n    \n    Args:\n        value: The temperature value to convert\n        from_unit: Source unit ('C', 'F', or 'K')\n        to_unit: Target unit ('C', 'F', or 'K')\n    \n    Returns:\n        The converted temperature value\n    \"\"\"\n    # Convert to Celsius first\n    if from_unit == 'F':\n        celsius = (value - 32) * 5/9\n    elif from_unit == 'K':\n        celsius = value - 273.15\n    else:\n        celsius = value\n    \n    # Convert to target\n    if to_unit == 'F':\n        return celsius * 9/5 + 32\n    elif to_unit == 'K':\n        return celsius + 273.15\n    else:\n        return celsius\n```\n\nTest:\n```bash\ncurl -X POST http://localhost:8080/invocations \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"prompt\": \"What is 100 Fahrenheit in Celsius?\"}'\n```\n\n## Calling External APIs\n\nTools can call external services:\n\n```python\nimport httpx\n\n@tool\ndef get_weather(city: str) -> dict:\n    \"\"\"Get current weather for a city.\n    \n    Args:\n        city: Name of the city (e.g., 'Seattle', 'New York')\n    \n    Returns:\n        Weather data including temperature and conditions\n    \"\"\"\n    # Using a weather API (example)\n    response = httpx.get(\n        f\"https://api.weather.example/current\",\n        params={\"city\": city},\n        headers={\"Authorization\": f\"Bearer {API_KEY}\"}\n    )\n    response.raise_for_status()\n    return response.json()\n```\n\n## Error Handling in Tools\n\nReturn structured errors instead of raising exceptions:\n\n```python\n@tool\ndef get_order_status(order_id: str) -> dict:\n    \"\"\"Get the status of a customer order.\n    \n    Args:\n        order_id: The order identifier\n    \"\"\"\n    try:\n        order = database.get_order(order_id)\n        if not order:\n            return {\n                \"error\": \"not_found\",\n                \"message\": f\"Order {order_id} not found\"\n            }\n        return {\n            \"order_id\": order.id,\n            \"status\": order.status,\n            \"estimated_delivery\": order.delivery_date\n        }\n    except DatabaseError as e:\n        return {\n            \"error\": \"database_error\",\n            \"message\": \"Unable to check order status. Please try again.\"\n        }\n```\n\nThe agent receives this error info and explains it naturally to the user.\n\n## Async Tools\n\nFor I/O-bound operations, use async:\n\n```python\n@tool\nasync def fetch_product_info(product_id: str) -> dict:\n    \"\"\"Fetch detailed product information from the catalog.\n    \n    Args:\n        product_id: The product identifier\n    \"\"\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(\n            f\"https://api.example.com/products/{product_id}\"\n        )\n        return response.json()\n```\n\n## Organizing Tools\n\nFor larger projects, organize tools into modules:\n\n```\nmy-agent/\n├── agent.py\n├── tools/\n│   ├── __init__.py\n│   ├── time_tools.py\n│   ├── math_tools.py\n│   └── api_tools.py\n└── requirements.txt\n```\n\n`tools/time_tools.py`:\n```python\nfrom strands import tool\nfrom datetime import datetime\n\n@tool\ndef get_current_time() -> str:\n    \"\"\"Get the current date and time.\"\"\"\n    return datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n@tool\ndef get_timezone_time(timezone: str) -> str:\n    \"\"\"Get current time in a specific timezone.\"\"\"\n    ...\n```\n\n`agent.py`:\n```python\nfrom tools.time_tools import get_current_time, get_timezone_time\nfrom tools.math_tools import calculate, convert_units\nfrom tools.api_tools import get_weather, get_stock_price\n\nagent = Agent(tools=[\n    get_current_time,\n    get_timezone_time,\n    calculate,\n    convert_units,\n    get_weather,\n    get_stock_price\n])\n```\n\n## Testing Your Tools\n\nTest tools independently before integrating:\n\n```python\n# test_tools.py\nfrom tools.math_tools import calculate\n\ndef test_calculate_addition():\n    result = calculate(\"2 + 2\")\n    assert result == 4\n\ndef test_calculate_sqrt():\n    result = calculate(\"sqrt(16)\")\n    assert result == 4.0\n\ndef test_calculate_complex():\n    result = calculate(\"(10 + 5) * 2\")\n    assert result == 30\n```\n\nRun:\n```bash\npython -m pytest test_tools.py\n```\n\n## Deploy with Tools\n\nDeployment works the same way:\n\n```bash\n# Ensure all tool dependencies are in requirements.txt\nagentcore configure -e agent.py\nagentcore launch\n```\n\n## Seeing Tool Calls\n\nTo see which tools were called:\n\n```python\n@app.entrypoint\ndef invoke(payload):\n    user_message = payload.get(\"prompt\", \"Hello!\")\n    result = agent(user_message)\n    \n    return {\n        \"result\": result.message,\n        \"tools_used\": [t.name for t in result.tools_used]\n    }\n```\n\nResponse:\n```json\n{\n  \"result\": \"It's 2:30 PM and 25 * 4 = 100.\",\n  \"tools_used\": [\"get_current_time\", \"calculate\"]\n}\n```\n\n## Complete Example\n\nHere's a fully-featured agent with multiple tools:\n\n```python\nfrom bedrock_agentcore import BedrockAgentCoreApp\nfrom strands import Agent, tool\nfrom datetime import datetime\nimport math\n\napp = BedrockAgentCoreApp()\n\n@tool\ndef get_current_time() -> str:\n    \"\"\"Get the current date and time.\"\"\"\n    return datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n@tool\ndef calculate(expression: str) -> float:\n    \"\"\"Evaluate a mathematical expression.\n    \n    Args:\n        expression: A math expression like '2 + 2' or 'sqrt(16)'\n    \"\"\"\n    allowed = {k: v for k, v in math.__dict__.items() if not k.startswith(\"_\")}\n    return eval(expression, {\"__builtins__\": {}}, allowed)\n\n@tool\ndef convert_temperature(value: float, from_unit: str, to_unit: str) -> float:\n    \"\"\"Convert temperature between C, F, and K.\n    \n    Args:\n        value: Temperature value\n        from_unit: 'C', 'F', or 'K'\n        to_unit: 'C', 'F', or 'K'\n    \"\"\"\n    if from_unit == 'F':\n        celsius = (value - 32) * 5/9\n    elif from_unit == 'K':\n        celsius = value - 273.15\n    else:\n        celsius = value\n    \n    if to_unit == 'F':\n        return round(celsius * 9/5 + 32, 2)\n    elif to_unit == 'K':\n        return round(celsius + 273.15, 2)\n    return round(celsius, 2)\n\nagent = Agent(\n    tools=[get_current_time, calculate, convert_temperature],\n    system_prompt=\"You are a helpful assistant with access to time, math, and temperature conversion tools.\"\n)\n\n@app.entrypoint\ndef invoke(payload):\n    user_message = payload.get(\"prompt\", \"Hello!\")\n    result = agent(user_message)\n    return {\"result\": result.message}\n\nif __name__ == \"__main__\":\n    app.run()\n```\n\n## Congratulations!\n\nYou've built a working agent with custom tools! You can now:\n- Create tools with the `@tool` decorator\n- Handle parameters and return structured data\n- Integrate with external APIs\n- Deploy tool-enabled agents to production\n\nNext modules will cover advanced topics like memory integration, security, and scaling."
}
