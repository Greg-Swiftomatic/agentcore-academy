{
  "title": "Multi-Agent Orchestration",
  "objectives": [
    "Design multi-agent systems using hierarchical, sequential, and parallel patterns",
    "Implement agent communication through message passing and shared memory",
    "Handle failures and state management in multi-agent orchestration"
  ],
  "content": "# Multi-Agent Orchestration\n\nComplex tasks often exceed what a single agent can handle effectively. Multi-agent systems distribute work across specialized agents, enabling more sophisticated capabilities.\n\n## Why Multi-Agent Systems?\n\n```\n┌─────────────────────────────────────────────────────────────────┐\n│                 Single Agent Limitations                         │\n│                                                                  │\n│  ┌──────────────────────────────────────────────────────────┐   │\n│  │ Context Window: Can only process ~100K tokens at once    │   │\n│  │ Specialization: Jack of all trades, master of none       │   │\n│  │ Complexity: Large tasks become unwieldy                  │   │\n│  │ Latency: Sequential processing of everything             │   │\n│  └──────────────────────────────────────────────────────────┘   │\n│                                                                  │\n│                 Multi-Agent Advantages                           │\n│                                                                  │\n│  ┌──────────────────────────────────────────────────────────┐   │\n│  │ Distributed: Spread work across multiple contexts        │   │\n│  │ Specialized: Each agent optimized for its role           │   │\n│  │ Modular: Clear separation of concerns                    │   │\n│  │ Parallel: Process independent tasks concurrently         │   │\n│  └──────────────────────────────────────────────────────────┘   │\n└─────────────────────────────────────────────────────────────────┘\n```\n\n## Orchestration Patterns\n\n### 1. Hierarchical (Supervisor Pattern)\n\nA supervisor agent decomposes tasks and coordinates worker agents:\n\n```\n                  ┌─────────────────────┐\n                  │   Supervisor Agent  │\n                  │  (Decompose & Route)│\n                  └──────────┬──────────┘\n                             │\n           ┌─────────────────┼─────────────────┐\n           ▼                 ▼                 ▼\n    ┌────────────┐   ┌────────────┐   ┌────────────┐\n    │   Coder    │   │   Tester   │   │   Writer   │\n    │   Agent    │   │   Agent    │   │   Agent    │\n    └────────────┘   └────────────┘   └────────────┘\n```\n\n```python\nfrom agentcore import Agent, SupervisorAgent\n\n# Define specialized workers\ncoder = Agent(\n    name=\"coder\",\n    instructions=\"Write clean, efficient Python code.\",\n    model=\"claude-3-sonnet\"\n)\n\ntester = Agent(\n    name=\"tester\",\n    instructions=\"Write comprehensive pytest tests.\",\n    model=\"claude-3-haiku\"  # Cheaper for simpler task\n)\n\ndocs_writer = Agent(\n    name=\"docs-writer\",\n    instructions=\"Write clear docstrings and README content.\",\n    model=\"claude-3-haiku\"\n)\n\n# Supervisor coordinates\nsupervisor = SupervisorAgent(\n    name=\"dev-lead\",\n    instructions=\"\"\"\n    Break down development tasks into coding, testing, and documentation.\n    Assign to appropriate workers and aggregate results.\n    \"\"\",\n    workers=[coder, tester, docs_writer],\n    routing_strategy=\"task_based\"\n)\n\nresult = await supervisor.run(\"Create a function to parse CSV files\")\n```\n\n### 2. Sequential Pipeline\n\nAgents process in order, each passing output to the next:\n\n```\nInput → [Extract] → [Validate] → [Enrich] → [Format] → Output\n```\n\n```python\nfrom agentcore import Pipeline\n\n# Define pipeline stages\nextractor = Agent(name=\"extractor\", instructions=\"Extract key data from documents\")\nvalidator = Agent(name=\"validator\", instructions=\"Validate extracted data for accuracy\")\nenricher = Agent(name=\"enricher\", instructions=\"Add context and related information\")\nformatter = Agent(name=\"formatter\", instructions=\"Format for final output\")\n\n# Create pipeline\npipeline = Pipeline(\n    stages=[extractor, validator, enricher, formatter],\n    pass_through_failures=False  # Stop on first failure\n)\n\nresult = await pipeline.run(document)\n```\n\n**Use cases:**\n- Document processing workflows\n- Data transformation chains\n- Review and approval processes\n\n### 3. Parallel Fan-Out/Fan-In\n\nMultiple agents process simultaneously, results aggregated:\n\n```\n              ┌─► [Researcher A] ─┐\n              │                   │\n Query ───────┼─► [Researcher B] ─┼──► Aggregator → Answer\n              │                   │\n              └─► [Researcher C] ─┘\n```\n\n```python\nfrom agentcore import ParallelExecutor\n\n# Multiple research agents\nresearchers = [\n    Agent(name=\"web-researcher\", instructions=\"Search web sources\"),\n    Agent(name=\"doc-researcher\", instructions=\"Search documentation\"),\n    Agent(name=\"code-researcher\", instructions=\"Search code examples\")\n]\n\nexecutor = ParallelExecutor(\n    agents=researchers,\n    aggregation_strategy=\"merge_deduplicate\",\n    timeout_per_agent=30\n)\n\n# All run concurrently\nresults = await executor.run(\"How do I implement OAuth in Python?\")\n```\n\n### 4. Debate Pattern\n\nAgents with different perspectives reach consensus:\n\n```python\nfrom agentcore import DebateOrchestrator\n\noptimist = Agent(\n    name=\"advocate\",\n    instructions=\"Argue for the proposed solution. Find its strengths.\"\n)\n\nskeptic = Agent(\n    name=\"critic\", \n    instructions=\"Challenge the proposal. Find weaknesses and risks.\"\n)\n\njudge = Agent(\n    name=\"judge\",\n    instructions=\"Evaluate arguments from both sides. Reach balanced conclusion.\"\n)\n\ndebate = DebateOrchestrator(\n    proposer=optimist,\n    critic=skeptic,\n    judge=judge,\n    max_rounds=3\n)\n\nconclusion = await debate.resolve(\"Should we migrate to microservices?\")\n```\n\n## Agent Communication\n\n### Message Passing\n\n```python\nfrom agentcore import Message\n\nclass AgentMessage:\n    sender: str           # Agent ID\n    recipient: str        # Target agent or \"broadcast\"\n    content: str          # Message content\n    message_type: str     # \"request\", \"response\", \"notification\"\n    context: dict         # Additional metadata\n\n# Send targeted message\nawait orchestrator.send_message(\n    Message(\n        sender=\"supervisor\",\n        recipient=\"coder\",\n        content=\"Write a CSV parser function\",\n        message_type=\"request\"\n    )\n)\n```\n\n### Shared Memory\n\n```python\nfrom agentcore import Memory\n\nmemory = Memory()\n\n# Agent A writes analysis results\nawait memory.write(\n    key=\"security_analysis\",\n    value=analysis_results,\n    scope=\"session\",  # Available to all agents in this session\n    ttl=3600\n)\n\n# Agent B reads the results\nanalysis = await memory.read(\n    key=\"security_analysis\",\n    scope=\"session\"\n)\n```\n\n### Event-Based Coordination\n\n```python\n# Agent subscribes to events\n@agent.on_event(\"code_complete\")\nasync def on_code_complete(event):\n    # Automatically run tests when code is ready\n    await run_tests(event.data.code)\n\n# Another agent emits the event\nawait orchestrator.emit(\n    event=\"code_complete\",\n    data={\"code\": generated_code, \"agent\": \"coder\"}\n)\n```\n\n## State Management\n\n### Orchestration State\n\n```python\nclass OrchestrationState:\n    session_id: str\n    status: str  # \"running\", \"paused\", \"completed\", \"failed\"\n    current_phase: str\n    agent_states: dict[str, AgentState]\n    task_queue: list[Task]\n    completed_tasks: list[Task]\n    shared_context: dict\n```\n\n### Checkpointing for Recovery\n\n```python\norchestrator = SupervisorAgent(\n    workers=[...],\n    checkpoint_strategy=\"after_each_task\",\n    checkpoint_storage=\"dynamodb\"\n)\n\n# Automatic checkpoints happen after each task\n\n# Manual checkpoint\nawait orchestrator.checkpoint()\n\n# Resume from checkpoint after failure\norchestrator = SupervisorAgent.resume_from_checkpoint(\n    checkpoint_id=\"chk_abc123\"\n)\n```\n\n## Error Handling\n\n```python\norchestrator = SupervisorAgent(\n    workers=[agent_a, agent_b, agent_c],\n    failure_policy={\n        \"max_retries\": 3,\n        \"retry_delay\": \"exponential\",\n        \"fallback_agent\": backup_agent,  # Use if primary fails\n        \"on_total_failure\": \"escalate_to_human\"\n    },\n    timeout_policy={\n        \"overall_timeout\": 300,      # 5 min total\n        \"per_agent_timeout\": 60,     # 1 min per agent\n        \"on_timeout\": \"return_partial\"  # Return what we have\n    }\n)\n```\n\n## Cost Optimization\n\nMulti-agent systems multiply LLM costs. Optimize:\n\n```python\n# Right-size models per agent\nfast_agent = Agent(model=\"claude-3-haiku\")     # Simple tasks: $0.25/1M\nbalanced_agent = Agent(model=\"claude-3-sonnet\") # Complex: $3/1M\npower_agent = Agent(model=\"claude-3-opus\")      # Critical: $15/1M\n\n# Cache common responses\norchestrator = SupervisorAgent(\n    workers=[...],\n    response_cache=True,\n    cache_ttl=3600\n)\n\n# Early termination\nresult = await orchestrator.run(\n    task=task,\n    early_stop_condition=lambda r: r.confidence > 0.95\n)\n```\n\n## Complete Example: Code Review System\n\n```python\nfrom agentcore import SupervisorAgent, Agent\n\n# Specialized reviewers\nsecurity_reviewer = Agent(\n    name=\"security\",\n    instructions=\"Find security vulnerabilities, injection risks, auth issues.\",\n    model=\"claude-3-sonnet\"  # More capable for security\n)\n\nperformance_reviewer = Agent(\n    name=\"performance\",\n    instructions=\"Identify performance issues, complexity, resource usage.\",\n    model=\"claude-3-haiku\"  # Faster, cheaper\n)\n\nstyle_reviewer = Agent(\n    name=\"style\",\n    instructions=\"Check code style, readability, best practices.\",\n    model=\"claude-3-haiku\"\n)\n\n# Supervisor aggregates reviews\nreview_supervisor = SupervisorAgent(\n    name=\"review-coordinator\",\n    instructions=\"\"\"\n    Coordinate code review across security, performance, and style.\n    Run all reviews in parallel. Aggregate findings, remove duplicates,\n    and prioritize issues by severity.\n    \"\"\",\n    workers=[security_reviewer, performance_reviewer, style_reviewer],\n    execution_mode=\"parallel\",  # All reviewers run concurrently\n    aggregation_prompt=\"Combine reviews into unified report with priority ranking\"\n)\n\n# Execute review\nreview = await review_supervisor.run(f\"Review this code:\\n{code}\")\nprint(review.unified_report)\n```\n\n## Summary\n\nMulti-agent orchestration patterns:\n\n1. **Hierarchical**: Supervisor decomposes and delegates to workers\n2. **Sequential**: Pipeline of agents, each processing in order\n3. **Parallel**: Concurrent execution, results aggregated\n4. **Debate**: Multiple perspectives reaching consensus\n\nKey considerations:\n- Clear agent responsibilities (single purpose per agent)\n- Efficient communication (minimize back-and-forth)\n- Robust error handling (retries, fallbacks, timeouts)\n- Cost optimization (right-size models, cache, early termination)"
}
