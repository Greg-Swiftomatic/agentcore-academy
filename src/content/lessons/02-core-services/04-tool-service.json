{
  "title": "Gateway & Tool Integration",
  "objectives": [
    "Understand how the Gateway Service handles API requests",
    "Learn how tools are registered and discovered",
    "Master tool integration patterns"
  ],
  "content": "# Gateway & Tool Integration\n\nThe Gateway Service is the front door to AgentCore, handling all incoming requests. Combined with tool integration, it enables agents to interact with the outside world.\n\n## Gateway Service Architecture\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                     Gateway Service                          │\n│                                                              │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │                  Load Balancer                        │    │\n│  └──────────────────────┬──────────────────────────────┘    │\n│                         │                                    │\n│     ┌───────────────────┼───────────────────┐               │\n│     ▼                   ▼                   ▼               │\n│  ┌───────────┐   ┌───────────┐   ┌───────────┐             │\n│  │   HTTP    │   │ WebSocket │   │   gRPC    │             │\n│  │  Handler  │   │  Handler  │   │  Handler  │             │\n│  └─────┬─────┘   └─────┬─────┘   └─────┬─────┘             │\n│        │               │               │                    │\n│        └───────────────┴───────────────┘                    │\n│                        │                                    │\n│                        ▼                                    │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │              Request Pipeline                         │    │\n│  │  Auth → Rate Limit → Validate → Route → Transform    │    │\n│  └─────────────────────────────────────────────────────┘    │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Request Pipeline\n\n### 1. Authentication\n\n```python\nasync def authenticate(request: Request) -> AuthContext:\n    # Extract credentials\n    api_key = request.headers.get(\"X-API-Key\")\n    bearer_token = request.headers.get(\"Authorization\")\n    \n    if api_key:\n        return await validate_api_key(api_key)\n    elif bearer_token:\n        return await validate_jwt(bearer_token)\n    else:\n        raise AuthenticationError(\"No credentials provided\")\n```\n\n### 2. Rate Limiting\n\n```python\nRATE_LIMITS = {\n    \"free\": {\"requests_per_minute\": 10, \"tokens_per_day\": 10000},\n    \"pro\": {\"requests_per_minute\": 100, \"tokens_per_day\": 1000000},\n    \"enterprise\": {\"requests_per_minute\": 1000, \"tokens_per_day\": None}\n}\n\nasync def check_rate_limit(auth: AuthContext) -> bool:\n    limits = RATE_LIMITS[auth.tier]\n    current = await get_usage(auth.user_id)\n    \n    if current.requests_this_minute >= limits[\"requests_per_minute\"]:\n        raise RateLimitExceeded(\"Too many requests\")\n    \n    return True\n```\n\n### 3. Request Validation\n\n```python\nfrom pydantic import BaseModel\n\nclass AgentRequest(BaseModel):\n    session_id: str | None = None\n    message: str\n    tools: list[str] | None = None\n    max_tokens: int = 4096\n    stream: bool = True\n\nasync def validate_request(request: Request) -> AgentRequest:\n    body = await request.json()\n    return AgentRequest(**body)  # Validates against schema\n```\n\n## Tool Registry\n\nTools are registered and discovered through the Gateway:\n\n```python\nclass ToolRegistry:\n    def __init__(self):\n        self.tools: dict[str, Tool] = {}\n    \n    def register(self, tool: Tool):\n        \"\"\"Register a tool for use by agents.\"\"\"\n        self.tools[tool.name] = tool\n    \n    def get(self, name: str) -> Tool:\n        \"\"\"Get a tool by name.\"\"\"\n        return self.tools.get(name)\n    \n    def list_for_agent(self, agent_id: str) -> list[Tool]:\n        \"\"\"Get tools available to an agent.\"\"\"\n        permissions = get_agent_permissions(agent_id)\n        return [t for t in self.tools.values() \n                if t.name in permissions.allowed_tools]\n```\n\n## Defining Tools\n\n### Tool Schema\n\n```python\nfrom pydantic import BaseModel, Field\n\nclass WeatherInput(BaseModel):\n    city: str = Field(description=\"City name\")\n    units: str = Field(default=\"celsius\", description=\"Temperature units\")\n\nclass WeatherOutput(BaseModel):\n    temperature: float\n    conditions: str\n    humidity: float\n\n@tool(\n    name=\"get_weather\",\n    description=\"Get current weather for a city\",\n    input_schema=WeatherInput,\n    output_schema=WeatherOutput\n)\nasync def get_weather(input: WeatherInput) -> WeatherOutput:\n    data = await weather_api.fetch(input.city, input.units)\n    return WeatherOutput(\n        temperature=data[\"temp\"],\n        conditions=data[\"conditions\"],\n        humidity=data[\"humidity\"]\n    )\n```\n\n### Tool Categories\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                      Tool Categories                         │\n├─────────────────┬─────────────────┬─────────────────────────┤\n│   Information   │     Action      │      Integration        │\n├─────────────────┼─────────────────┼─────────────────────────┤\n│ search_web      │ send_email      │ query_database          │\n│ get_weather     │ create_ticket   │ call_api                │\n│ lookup_docs     │ update_record   │ trigger_workflow        │\n│ get_time        │ schedule_event  │ post_to_slack           │\n└─────────────────┴─────────────────┴─────────────────────────┘\n```\n\n## Tool Execution Patterns\n\n### Synchronous Tools\n\nFor quick operations:\n\n```python\n@tool(execution_mode=\"sync\")\nasync def calculate(expression: str) -> float:\n    return eval(expression)  # Quick computation\n```\n\n### Asynchronous Tools\n\nFor long-running operations:\n\n```python\n@tool(execution_mode=\"async\")\nasync def generate_report(data: dict) -> str:\n    # Start the job\n    job_id = await start_report_job(data)\n    \n    # Return job ID for polling\n    return f\"Job started: {job_id}. Use check_job_status to monitor.\"\n```\n\n### Streaming Tools\n\nFor large data operations:\n\n```python\n@tool(execution_mode=\"stream\")\nasync def search_documents(query: str):\n    async for result in document_search(query):\n        yield result  # Stream results as found\n```\n\n## Error Handling\n\n```python\nclass ToolError(Exception):\n    \"\"\"Base class for tool errors.\"\"\"\n    pass\n\nclass ToolNotFoundError(ToolError):\n    \"\"\"Tool doesn't exist.\"\"\"\n    pass\n\nclass ToolPermissionError(ToolError):\n    \"\"\"Agent lacks permission to use tool.\"\"\"\n    pass\n\nclass ToolExecutionError(ToolError):\n    \"\"\"Tool failed during execution.\"\"\"\n    pass\n\nasync def execute_tool_safely(tool_call: ToolCall) -> ToolResult:\n    try:\n        tool = registry.get(tool_call.name)\n        if not tool:\n            raise ToolNotFoundError(f\"Tool not found: {tool_call.name}\")\n        \n        result = await tool.execute(tool_call.parameters)\n        return ToolResult(success=True, output=result)\n        \n    except ToolError as e:\n        # Return error to agent for handling\n        return ToolResult(success=False, error=str(e))\n```\n\n## API Endpoints\n\n### Chat Endpoint\n\n```\nPOST /v1/agents/{agent_id}/chat\n\nRequest:\n{\n  \"session_id\": \"optional-session-id\",\n  \"message\": \"What's the weather in Seattle?\",\n  \"stream\": true\n}\n\nResponse (streaming):\ndata: {\"type\": \"text\", \"content\": \"Let me check \"}\ndata: {\"type\": \"tool_use\", \"tool\": \"get_weather\", \"input\": {...}}\ndata: {\"type\": \"tool_result\", \"output\": {...}}\ndata: {\"type\": \"text\", \"content\": \"The weather in Seattle is...\"}\ndata: {\"type\": \"done\"}\n```\n\n### Tool Management Endpoints\n\n```\nGET /v1/tools                    # List available tools\nPOST /v1/tools                   # Register new tool\nGET /v1/tools/{tool_id}          # Get tool details\nDELETE /v1/tools/{tool_id}       # Remove tool\nPOST /v1/tools/{tool_id}/test    # Test tool execution\n```\n\n## Best Practices\n\n### 1. Design Clear Tool Interfaces\n\n```python\n# Good: Clear, specific purpose\n@tool(description=\"Search for products by name, category, or price range\")\nasync def search_products(name: str = None, category: str = None, \n                          min_price: float = None, max_price: float = None):\n    pass\n\n# Bad: Vague, overly general\n@tool(description=\"Do stuff with products\")\nasync def product_tool(action: str, data: dict):\n    pass\n```\n\n### 2. Include Helpful Descriptions\n\n```python\n@tool(\n    name=\"schedule_meeting\",\n    description=\"\"\"Schedule a meeting with attendees.\n    \n    Use this when the user wants to set up a meeting.\n    Requires at least one attendee email and a time.\n    The meeting will be added to the primary calendar.\n    \"\"\"\n)\nasync def schedule_meeting(...):\n    pass\n```\n\n### 3. Handle Errors Gracefully\n\n```python\n@tool\nasync def fetch_user_data(user_id: str) -> dict:\n    try:\n        return await database.get_user(user_id)\n    except UserNotFound:\n        return {\"error\": f\"User {user_id} not found\"}\n    except DatabaseError as e:\n        return {\"error\": \"Database temporarily unavailable\", \"retry\": True}\n```\n\n## Next Steps\n\nYou now understand how the Gateway and tools work together. In the next module, we'll explore agent design patterns for building effective AI agents."
}
