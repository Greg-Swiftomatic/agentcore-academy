{
  "title": "Memory Service Deep Dive",
  "objectives": [
    "Understand how agents store and retrieve context",
    "Learn about different memory types and their use cases",
    "Master context window management strategies"
  ],
  "content": "# Memory Service Deep Dive\n\nAgents need memory. Without it, every conversation starts from scratch. The Memory Service provides persistent, efficient storage for agent context.\n\n## Why Memory Matters\n\nConsider this conversation:\n\n```\nUser: My name is Alice.\nAgent: Nice to meet you, Alice!\n\n[5 minutes later...]\n\nUser: What's my name?\nAgent: ??? (without memory, this fails)\n```\n\nMemory allows agents to:\n- Remember conversation history\n- Track task progress\n- Store user preferences\n- Maintain context across sessions\n\n## Memory Architecture\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                     Memory Service                           │\n│                                                              │\n│  ┌─────────────────────────────────────────────────────┐    │\n│  │                   Memory Manager                      │    │\n│  └──────────────────────┬──────────────────────────────┘    │\n│                         │                                    │\n│     ┌───────────────────┼───────────────────┐               │\n│     ▼                   ▼                   ▼               │\n│  ┌───────────┐   ┌───────────┐   ┌───────────┐             │\n│  │  Session  │   │  Entity   │   │  Summary  │             │\n│  │  Store    │   │  Store    │   │  Store    │             │\n│  │           │   │           │   │           │             │\n│  │ Short-term│   │ Long-term │   │ Compressed│             │\n│  │ messages  │   │ knowledge │   │ history   │             │\n│  └─────┬─────┘   └─────┬─────┘   └─────┬─────┘             │\n│        │               │               │                    │\n│        └───────────────┴───────────────┘                    │\n│                        │                                    │\n│                        ▼                                    │\n│                  ┌───────────┐                              │\n│                  │ DynamoDB  │                              │\n│                  └───────────┘                              │\n└─────────────────────────────────────────────────────────────┘\n```\n\n## Memory Types\n\n### 1. Session Memory\n\nShort-term storage for active conversations:\n\n```python\nclass SessionMemory:\n    session_id: str\n    messages: list[Message]  # Recent conversation\n    variables: dict          # Temporary state\n    created_at: datetime\n    expires_at: datetime     # TTL for cleanup\n```\n\n**Use cases:**\n- Current conversation history\n- Active task state\n- Temporary user inputs\n\n### 2. Entity Memory\n\nLong-term storage for persistent knowledge:\n\n```python\nclass EntityMemory:\n    user_id: str\n    entities: dict[str, Entity]\n    \n    # Example entities:\n    # \"user_name\": \"Alice\"\n    # \"user_preferences\": {\"language\": \"en\"}\n    # \"previous_orders\": [...]}\n```\n\n**Use cases:**\n- User preferences\n- Learned facts\n- Historical data\n\n### 3. Summary Memory\n\nCompressed history for context efficiency:\n\n```python\nclass SummaryMemory:\n    session_id: str\n    summary: str        # Condensed conversation\n    key_points: list    # Important extracted facts\n    token_count: int    # Current size\n```\n\n**Use cases:**\n- Long conversations\n- Context window management\n- Historical reference\n\n## Context Window Management\n\nLLMs have limited context windows. The Memory Service helps manage this:\n\n```\n┌─────────────────────────────────────────────┐\n│           Context Window (100K tokens)       │\n├─────────────────────────────────────────────┤\n│  System Prompt (2K)                          │\n├─────────────────────────────────────────────┤\n│  Summary of older messages (5K)              │\n├─────────────────────────────────────────────┤\n│  Entity memory - relevant facts (3K)         │\n├─────────────────────────────────────────────┤\n│  Recent messages - full text (20K)           │\n├─────────────────────────────────────────────┤\n│  Current user message (1K)                   │\n├─────────────────────────────────────────────┤\n│  Reserved for response (10K)                 │\n├─────────────────────────────────────────────┤\n│  Buffer / Unused (59K)                       │\n└─────────────────────────────────────────────┘\n```\n\n### Summarization Strategy\n\n```python\nasync def manage_context(session_id: str, new_message: Message):\n    memory = await load_memory(session_id)\n    \n    # Calculate current token usage\n    total_tokens = count_tokens(memory.messages)\n    \n    if total_tokens > MAX_TOKENS * 0.8:  # 80% threshold\n        # Summarize older messages\n        old_messages = memory.messages[:-KEEP_RECENT]\n        summary = await llm.summarize(old_messages)\n        \n        # Replace old messages with summary\n        memory.summary = summary\n        memory.messages = memory.messages[-KEEP_RECENT:]\n        \n        await save_memory(session_id, memory)\n```\n\n## Data Model\n\n### DynamoDB Schema\n\n```\nTable: AgentMemory\n\nPrimary Key:\n  PK: \"SESSION#{session_id}\" or \"USER#{user_id}\"\n  SK: \"MESSAGE#{timestamp}\" or \"ENTITY#{name}\"\n\nGSI1:\n  GSI1PK: \"USER#{user_id}\"\n  GSI1SK: \"SESSION#{session_id}\"\n  (Query all sessions for a user)\n\nAttributes:\n  - type: \"message\" | \"entity\" | \"summary\"\n  - content: string\n  - metadata: map\n  - ttl: number (epoch seconds for expiration)\n```\n\n### Example Records\n\n```json\n// Message record\n{\n  \"PK\": \"SESSION#abc123\",\n  \"SK\": \"MESSAGE#2024-01-15T10:30:00Z\",\n  \"type\": \"message\",\n  \"role\": \"user\",\n  \"content\": \"What's the weather like?\",\n  \"ttl\": 1705401600\n}\n\n// Entity record\n{\n  \"PK\": \"USER#user456\",\n  \"SK\": \"ENTITY#name\",\n  \"type\": \"entity\",\n  \"value\": \"Alice\",\n  \"confidence\": 0.95,\n  \"source\": \"user_stated\"\n}\n```\n\n## Memory Operations\n\n### Reading Memory\n\n```python\nasync def get_context(session_id: str, user_id: str) -> Context:\n    # Parallel reads for efficiency\n    session, entities = await asyncio.gather(\n        get_session_memory(session_id),\n        get_entity_memory(user_id)\n    )\n    \n    return Context(\n        messages=session.messages,\n        summary=session.summary,\n        entities=entities,\n        variables=session.variables\n    )\n```\n\n### Writing Memory\n\n```python\nasync def save_context(session_id: str, context: Context):\n    # Batch write for efficiency\n    async with memory_client.batch() as batch:\n        # Save new messages\n        for msg in context.new_messages:\n            batch.put(session_message_record(session_id, msg))\n        \n        # Update summary if changed\n        if context.summary_updated:\n            batch.put(session_summary_record(session_id, context.summary))\n        \n        # Save extracted entities\n        for entity in context.new_entities:\n            batch.put(entity_record(context.user_id, entity))\n```\n\n## Best Practices\n\n### 1. Set Appropriate TTLs\n\n```python\n# Session data: 24 hours (active conversations)\nSESSION_TTL = 86400\n\n# Entity data: 90 days (user preferences)\nENTITY_TTL = 7776000\n\n# Summary data: 7 days (historical reference)\nSUMMARY_TTL = 604800\n```\n\n### 2. Extract Entities Proactively\n\n```python\nasync def extract_entities(messages: list[Message]) -> list[Entity]:\n    prompt = \"Extract key facts about the user from this conversation...\"\n    entities = await llm.extract(prompt, messages)\n    return entities\n```\n\n### 3. Implement Graceful Degradation\n\n```python\nasync def get_context_with_fallback(session_id: str) -> Context:\n    try:\n        return await get_full_context(session_id)\n    except MemoryError:\n        # Fall back to minimal context\n        return await get_recent_messages_only(session_id, limit=10)\n```\n\n## Next Steps\n\nYou now understand how agents maintain memory. Next, we'll explore the Tool Service and how agents interact with external capabilities."
}
