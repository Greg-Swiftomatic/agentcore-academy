{
  "title": "Implementation",
  "objectives": [
    "Build your agent using the AgentCore SDK",
    "Implement custom tools that connect to real data sources",
    "Configure memory and runtime settings for your use case"
  ],
  "content": "# Implementation\n\nTime to build. You have your requirements and architecture - now let's turn them into working code.\n\nThis lesson provides implementation patterns for each project type. Find your section and follow along.\n\n## Project Setup\n\nEvery project starts the same way:\n\n```bash\n# Create project directory\nmkdir my-capstone-agent\ncd my-capstone-agent\n\n# Initialize Python project\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install dependencies\npip install boto3 amazon-bedrock-agentcore\n\n# Create project structure\nmkdir -p src/tools tests\ntouch src/__init__.py src/agent.py src/tools/__init__.py\n```\n\n**Project structure:**\n```\nmy-capstone-agent/\n├── src/\n│   ├── __init__.py\n│   ├── agent.py         # Main agent definition\n│   ├── config.py        # Configuration\n│   └── tools/\n│       ├── __init__.py\n│       └── my_tools.py  # Your custom tools\n├── tests/\n│   └── test_agent.py\n├── data/                 # Your knowledge base or test data\n├── requirements.txt\n└── README.md\n```\n\n## Base Agent Template\n\nStart with this template, then customize for your project:\n\n```python\n# src/agent.py\nimport boto3\nfrom bedrock_agentcore import Agent, Tool, Memory\nfrom bedrock_agentcore.runtime import RuntimeConfig\n\n# Import your tools\nfrom tools.my_tools import search_faq, get_order_status\n\nclass MyCapstoneAgent:\n    def __init__(self):\n        # Initialize Bedrock client\n        self.bedrock = boto3.client('bedrock-runtime')\n        \n        # Configure runtime\n        self.runtime_config = RuntimeConfig(\n            model_id=\"anthropic.claude-3-sonnet-20240229-v1:0\",\n            max_tokens=1024,\n            temperature=0.7\n        )\n        \n        # Define tools\n        self.tools = [\n            Tool(\n                name=\"search_faq\",\n                description=\"Search the FAQ knowledge base\",\n                function=search_faq,\n                parameters={...}  # Your schema from architecture doc\n            ),\n            Tool(\n                name=\"get_order_status\",\n                description=\"Get order status by ID\",\n                function=get_order_status,\n                parameters={...}\n            )\n        ]\n        \n        # Configure memory\n        self.memory = Memory(\n            type=\"sliding_window\",\n            window_size=10\n        )\n        \n        # System prompt\n        self.system_prompt = \"\"\"\n        You are a helpful customer support agent for [Your Company].\n        \n        Your role is to:\n        - Answer questions about our products and policies\n        - Help customers check order status\n        - Escalate complex issues to human support\n        \n        Always be friendly, clear, and helpful.\n        If you don't know something, say so honestly.\n        \"\"\"\n    \n    def chat(self, user_message: str, session_id: str = None) -> str:\n        \"\"\"Process a user message and return a response.\"\"\"\n        \n        # Get conversation history from memory\n        history = self.memory.get(session_id) if session_id else []\n        \n        # Build messages\n        messages = [\n            {\"role\": \"system\", \"content\": self.system_prompt},\n            *history,\n            {\"role\": \"user\", \"content\": user_message}\n        ]\n        \n        # Create agent and invoke\n        agent = Agent(\n            runtime_config=self.runtime_config,\n            tools=self.tools,\n            messages=messages\n        )\n        \n        response = agent.invoke()\n        \n        # Store in memory\n        if session_id:\n            self.memory.add(session_id, {\n                \"role\": \"user\",\n                \"content\": user_message\n            })\n            self.memory.add(session_id, {\n                \"role\": \"assistant\", \n                \"content\": response.content\n            })\n        \n        return response.content\n\n# Simple test\nif __name__ == \"__main__\":\n    agent = MyCapstoneAgent()\n    response = agent.chat(\"What is your return policy?\")\n    print(response)\n```\n\n## Implementing Tools\n\nTools are where your agent connects to the real world. Here are patterns for common tool types:\n\n### Pattern 1: Knowledge Base Search\n\n```python\n# src/tools/my_tools.py\nimport json\nfrom pathlib import Path\n\n# Simple in-memory FAQ (replace with your data source)\nFAQ_DATA = None\n\ndef load_faq():\n    global FAQ_DATA\n    if FAQ_DATA is None:\n        faq_path = Path(__file__).parent.parent.parent / \"data\" / \"faq.json\"\n        with open(faq_path) as f:\n            FAQ_DATA = json.load(f)\n    return FAQ_DATA\n\ndef search_faq(query: str, category: str = None, max_results: int = 3) -> list:\n    \"\"\"\n    Search FAQ knowledge base.\n    \n    Args:\n        query: The search query\n        category: Optional category filter\n        max_results: Maximum results to return\n    \n    Returns:\n        List of matching FAQ entries with relevance scores\n    \"\"\"\n    faq = load_faq()\n    \n    # Simple keyword matching (replace with vector search for production)\n    query_words = set(query.lower().split())\n    results = []\n    \n    for entry in faq:\n        # Filter by category if specified\n        if category and entry.get(\"category\") != category:\n            continue\n        \n        # Calculate simple relevance score\n        entry_words = set(entry[\"question\"].lower().split())\n        overlap = len(query_words & entry_words)\n        \n        if overlap > 0:\n            results.append({\n                \"question\": entry[\"question\"],\n                \"answer\": entry[\"answer\"],\n                \"relevance_score\": overlap / len(query_words)\n            })\n    \n    # Sort by relevance and limit\n    results.sort(key=lambda x: x[\"relevance_score\"], reverse=True)\n    return results[:max_results]\n```\n\n**Sample FAQ data (`data/faq.json`):**\n```json\n[\n  {\n    \"question\": \"What is your return policy?\",\n    \"answer\": \"You can return any item within 30 days of purchase for a full refund. Items must be unused and in original packaging.\",\n    \"category\": \"returns\"\n  },\n  {\n    \"question\": \"How long does shipping take?\",\n    \"answer\": \"Standard shipping takes 5-7 business days. Express shipping takes 2-3 business days.\",\n    \"category\": \"shipping\"\n  }\n]\n```\n\n### Pattern 2: External API Call\n\n```python\nimport requests\nfrom functools import lru_cache\n\n@lru_cache(maxsize=100)\ndef get_order_status(order_id: str) -> dict:\n    \"\"\"\n    Get order status from the orders API.\n    \n    Args:\n        order_id: Order ID in format ORD-XXXXXX\n    \n    Returns:\n        Order status information\n    \"\"\"\n    # Validate format\n    if not order_id.startswith(\"ORD-\") or len(order_id) != 10:\n        return {\"error\": \"Invalid order ID format. Expected ORD-XXXXXX\"}\n    \n    try:\n        # Replace with your actual API\n        response = requests.get(\n            f\"https://api.yourcompany.com/orders/{order_id}\",\n            headers={\"Authorization\": f\"Bearer {API_KEY}\"},\n            timeout=10\n        )\n        \n        if response.status_code == 404:\n            return {\"error\": \"Order not found\"}\n        \n        response.raise_for_status()\n        return response.json()\n        \n    except requests.Timeout:\n        return {\"error\": \"Order lookup timed out. Please try again.\"}\n    except requests.RequestException as e:\n        return {\"error\": f\"Failed to fetch order: {str(e)}\"}\n```\n\n### Pattern 3: Action Tool\n\n```python\nimport uuid\nfrom datetime import datetime\n\ndef create_support_ticket(\n    subject: str,\n    description: str,\n    priority: str = \"medium\"\n) -> dict:\n    \"\"\"\n    Create a support ticket for human follow-up.\n    \n    Args:\n        subject: Brief subject line\n        description: Full description of the issue\n        priority: low, medium, high, or urgent\n    \n    Returns:\n        Ticket confirmation with ID\n    \"\"\"\n    # Validate priority\n    valid_priorities = [\"low\", \"medium\", \"high\", \"urgent\"]\n    if priority not in valid_priorities:\n        priority = \"medium\"\n    \n    # Create ticket (replace with your ticketing system)\n    ticket_id = f\"TKT-{uuid.uuid4().hex[:8].upper()}\"\n    \n    ticket = {\n        \"ticket_id\": ticket_id,\n        \"subject\": subject[:100],  # Enforce length limit\n        \"description\": description[:1000],\n        \"priority\": priority,\n        \"created_at\": datetime.utcnow().isoformat(),\n        \"status\": \"open\"\n    }\n    \n    # In production: save to database, notify team, etc.\n    # save_ticket(ticket)\n    # notify_support_team(ticket)\n    \n    return {\n        \"success\": True,\n        \"ticket_id\": ticket_id,\n        \"message\": f\"Ticket created. A support agent will respond within 24 hours.\"\n    }\n```\n\n## Project-Specific Implementation\n\n### Customer Support Agent\n\nKey additions:\n- Sentiment detection to identify frustrated customers\n- Escalation logic based on issue complexity\n- Session state to track customer journey\n\n```python\ndef detect_frustration(message: str) -> bool:\n    \"\"\"Simple frustration detection.\"\"\"\n    frustration_signals = [\n        \"angry\", \"frustrated\", \"terrible\", \"worst\",\n        \"never\", \"always\", \"!!\", \"???\", \"unacceptable\"\n    ]\n    message_lower = message.lower()\n    return any(signal in message_lower for signal in frustration_signals)\n\ndef should_escalate(session_state: dict) -> bool:\n    \"\"\"Determine if we should escalate to human.\"\"\"\n    return (\n        session_state.get(\"failed_searches\", 0) >= 2 or\n        session_state.get(\"frustration_detected\", False) or\n        session_state.get(\"explicit_human_request\", False)\n    )\n```\n\n### Research Assistant\n\nKey additions:\n- Multiple search sources\n- Result synthesis\n- Citation tracking\n\n```python\ndef search_all_sources(query: str) -> list:\n    \"\"\"Search multiple sources in parallel.\"\"\"\n    import concurrent.futures\n    \n    sources = [\n        (\"internal_docs\", search_internal_docs),\n        (\"web\", search_web),\n        (\"papers\", search_papers)\n    ]\n    \n    results = []\n    with concurrent.futures.ThreadPoolExecutor() as executor:\n        futures = {\n            executor.submit(func, query): name \n            for name, func in sources\n        }\n        for future in concurrent.futures.as_completed(futures):\n            source = futures[future]\n            try:\n                data = future.result(timeout=10)\n                results.extend([\n                    {**item, \"source\": source} \n                    for item in data\n                ])\n            except Exception as e:\n                print(f\"Search failed for {source}: {e}\")\n    \n    return results\n```\n\n### Data Analyst Agent\n\nKey additions:\n- SQL query generation (with safety limits)\n- Result formatting\n- Chart generation suggestions\n\n```python\ndef query_database(query: str, database: str = \"sales\") -> dict:\n    \"\"\"Execute a safe SQL query.\"\"\"\n    import sqlite3\n    \n    # Safety: only allow SELECT\n    if not query.strip().upper().startswith(\"SELECT\"):\n        return {\"error\": \"Only SELECT queries are allowed\"}\n    \n    # Safety: limit results\n    if \"LIMIT\" not in query.upper():\n        query = f\"{query} LIMIT 100\"\n    \n    try:\n        conn = sqlite3.connect(f\"data/{database}.db\")\n        cursor = conn.cursor()\n        cursor.execute(query)\n        \n        columns = [desc[0] for desc in cursor.description]\n        rows = cursor.fetchall()\n        \n        return {\n            \"columns\": columns,\n            \"rows\": rows,\n            \"row_count\": len(rows)\n        }\n    except sqlite3.Error as e:\n        return {\"error\": f\"Query failed: {str(e)}\"}\n    finally:\n        conn.close()\n```\n\n## Testing Your Implementation\n\nBefore moving on, test locally:\n\n```python\n# tests/test_agent.py\nimport pytest\nfrom src.agent import MyCapstoneAgent\n\ndef test_basic_chat():\n    agent = MyCapstoneAgent()\n    response = agent.chat(\"Hello!\")\n    assert response is not None\n    assert len(response) > 0\n\ndef test_faq_search():\n    agent = MyCapstoneAgent()\n    response = agent.chat(\"What is your return policy?\")\n    assert \"return\" in response.lower() or \"30 days\" in response\n\ndef test_tool_execution():\n    from src.tools.my_tools import search_faq\n    results = search_faq(\"return policy\")\n    assert isinstance(results, list)\n```\n\nRun tests:\n```bash\npytest tests/ -v\n```\n\n## Your Assignment\n\n1. **Set up your project structure** using the template above\n2. **Implement at least 2 tools** from your architecture document\n3. **Create sample data** for your knowledge base or data source\n4. **Write the main agent class** with proper configuration\n5. **Test locally** - make sure basic conversations work\n\n## Common Issues & Solutions\n\n| Issue | Solution |\n|-------|----------|\n| \"Model not found\" | Check model ID and Bedrock access |\n| Tool not called | Improve tool description, make purpose clearer |\n| Wrong tool called | Add examples to tool description |\n| Memory not working | Verify session_id is passed consistently |\n| Slow responses | Check tool timeout, consider caching |\n\n## What's Next\n\nYour agent works locally. In the next lesson, you'll test it thoroughly and iterate on improvements before deployment."
}
