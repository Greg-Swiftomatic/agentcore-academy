{
  "title": "Tool Selection Patterns",
  "objectives": [
    "Understand how agents decide which tools to use",
    "Master the four core tool selection patterns",
    "Learn best practices for tool descriptions that improve selection accuracy"
  ],
  "content": "# Tool Selection Patterns\n\nWhen an agent receives a request, it faces a critical decision: should I use a tool, and if so, which one? This lesson covers how agents make these decisions and the patterns you can use to guide them.\n\n## The Tool Selection Process\n\nEvery agent request follows a mental flow:\n\n```\nUser Request: \"What's the status of my order #12345?\"\n                │\n                ▼\n┌─────────────────────────────────────────┐\n│         Agent Reasoning                  │\n│                                         │\n│  1. Parse intent: check order status    │\n│  2. Identify needed info: order ID      │\n│  3. Search available tools              │\n│  4. Select: get_order_status            │\n│  5. Extract parameter: orderId=12345    │\n└─────────────────────────────────────────┘\n                │\n                ▼\n┌─────────────────────────────────────────┐\n│         Tool Execution                   │\n│  get_order_status(orderId=\"12345\")      │\n└─────────────────────────────────────────┘\n                │\n                ▼\n┌─────────────────────────────────────────┐\n│         Response Synthesis               │\n│  \"Your order #12345 shipped on Dec 30   │\n│   and will arrive by Jan 2.\"            │\n└─────────────────────────────────────────┘\n```\n\nThe agent's ability to select the right tool depends heavily on how well tools are described.\n\n## The Four Tool Selection Patterns\n\n### Pattern 1: Single Tool Selection\n\nThe simplest pattern - one tool answers the question:\n\n```python\nUser: \"What's the weather in Seattle?\"\nAgent selects: get_weather(location=\"Seattle\")\n```\n\nThis works when the user's intent maps clearly to a single tool.\n\n### Pattern 2: Sequential Tool Selection\n\nMultiple tools where later tools depend on earlier results:\n\n```python\nUser: \"Cancel my most recent order\"\n\nStep 1: get_recent_orders(user_id=user_id)\n        → Returns order #12345\n\nStep 2: cancel_order(order_id=\"12345\")\n        → Returns cancellation confirmation\n```\n\nThe agent must wait for the first tool's result before knowing what to pass to the second.\n\n### Pattern 3: Parallel Tool Selection\n\nMultiple independent tools executed simultaneously:\n\n```python\nUser: \"Compare the weather in Seattle and Portland\"\n\nParallel execution:\n  - get_weather(location=\"Seattle\")\n  - get_weather(location=\"Portland\")\n  \nBoth results combined in response\n```\n\nParallel execution is faster and should be used when tools don't depend on each other.\n\n### Pattern 4: Conditional Tool Selection\n\nChoose different tools based on context:\n\n```python\nUser: \"Help me with my order\"\n\nIf user has recent order:\n  → get_order_status(order_id=recent_order_id)\n  \nIf no recent order:\n  → search_orders(user_id=user_id)\n```\n\nThe agent uses available context to pick the most relevant tool.\n\n## Tool Descriptions: The Key to Good Selection\n\nThe model selects tools based on their descriptions. Poor descriptions lead to poor selection.\n\n### Bad Example\n\n```python\ntool = Tool(\n    name=\"get_data\",\n    description=\"Gets data from the system\"\n)\n# Too vague - when would the model use this?\n```\n\n### Good Example\n\n```python\ntool = Tool(\n    name=\"get_order_status\",\n    description=\"\"\"\n    Retrieves the current fulfillment status of a customer order.\n    Returns shipping status, tracking number, estimated delivery date,\n    and list of items in the order. Use this when customers ask about\n    where their order is, when it will arrive, or what's in their order.\n    \"\"\"\n)\n```\n\n### Description Best Practices\n\n1. **Be specific about what the tool does** - not just \"gets data\" but \"retrieves order fulfillment status\"\n2. **List what it returns** - helps the agent know if this tool provides the needed info\n3. **Include when to use it** - \"Use when customers ask about...\" guides selection\n4. **Mention what it doesn't do** - prevents misuse\n\n## Implementing Tool Selection with Strands\n\n```python\nfrom strands import Agent, tool\n\n@tool\ndef get_order_status(order_id: str) -> dict:\n    \"\"\"Get the current status of a customer order.\n    \n    Args:\n        order_id: The unique order identifier\n        \n    Returns:\n        Order status including shipping info and delivery estimate\n    \"\"\"\n    return order_service.get_status(order_id)\n\n@tool\ndef search_products(query: str, category: str = None) -> list:\n    \"\"\"Search the product catalog.\n    \n    Args:\n        query: Search terms\n        category: Optional category filter\n        \n    Returns:\n        List of matching products with prices and availability\n    \"\"\"\n    return catalog.search(query, category)\n\n# Agent automatically selects appropriate tools based on user input\nagent = Agent(tools=[get_order_status, search_products])\n\nresponse = agent(\"Where is order 12345?\")  # Uses get_order_status\nresponse = agent(\"Find red shoes\")  # Uses search_products\n```\n\n## Handling Tool Selection Errors\n\n### No Matching Tool\n\nWhen no tool fits the request:\n\n```python\ndef handle_request(prompt):\n    tools = gateway.search_tools(prompt, limit=5)\n    \n    if not tools:\n        return \"I'm sorry, I don't have the capability to help with that request.\"\n    \n    agent = Agent(tools=tools)\n    return agent(prompt)\n```\n\n### Ambiguous Tool Selection\n\nWhen multiple tools could work, add guidance:\n\n```python\ngateway.register_tool(\n    name=\"get_order_status\",\n    description=\"...\",\n    use_when=\"Customer asks about order status, shipping, or delivery\",\n    do_not_use_when=\"Customer wants to modify or cancel an order\"\n)\n```\n\n### Wrong Tool Selected\n\nTrain the model with examples:\n\n```python\nagent = Agent(\n    tools=tools,\n    examples=[\n        {\n            \"user\": \"Where is my order?\",\n            \"tool\": \"get_order_status\",\n            \"reasoning\": \"Customer is asking about order location/status\"\n        },\n        {\n            \"user\": \"I want to return my order\",\n            \"tool\": \"initiate_return\",\n            \"reasoning\": \"Customer wants to return, not check status\"\n        }\n    ]\n)\n```\n\n## Scaling: Tool Selection with Many Tools\n\nWhen agents have dozens or hundreds of tools:\n\n### Semantic Search\n\n```python\n# Don't load all tools - search for relevant ones\nrelevant_tools = gateway.search_tools(\n    query=user_message,\n    limit=10\n)\n\nagent = Agent(tools=relevant_tools)\n```\n\n### Tool Categories\n\n```python\n# Organize tools by domain\norder_tools = gateway.get_tools(category=\"orders\")\nproduct_tools = gateway.get_tools(category=\"products\")\nsupport_tools = gateway.get_tools(category=\"support\")\n\n# Select category based on intent classification\nif intent == \"order_inquiry\":\n    agent = Agent(tools=order_tools)\n```\n\n### Two-Stage Selection\n\n```python\n# Stage 1: Classify intent\nintent = classifier.classify(user_message)\n\n# Stage 2: Load relevant tools for that intent\nif intent == \"order\":\n    tools = gateway.get_tools(category=\"orders\")\nelif intent == \"product\":\n    tools = gateway.get_tools(category=\"products\")\nelse:\n    tools = gateway.get_tools(category=\"general\")\n\nagent = Agent(tools=tools)\n```\n\n## Monitoring Tool Selection\n\nTrack selection patterns to identify issues:\n\n```python\nfrom bedrock_agentcore.observability import trace\n\n@trace\ndef handle_request(prompt):\n    agent = Agent(tools=tools)\n    response = agent(prompt)\n    \n    # Log for analysis\n    logger.info({\n        \"prompt\": prompt,\n        \"tools_selected\": response.tools_used,\n        \"success\": response.success\n    })\n    \n    return response\n```\n\nAnalyze patterns over time:\n- Which tools are used most frequently?\n- Which prompts lead to wrong tool selection?\n- Are there capability gaps (requests with no matching tool)?\n\n## Key Takeaways\n\n1. **Tool descriptions are critical** - they determine selection accuracy\n2. **Use the right pattern** - single, sequential, parallel, or conditional\n3. **Handle errors gracefully** - no match, ambiguous, or wrong selection\n4. **Scale with search** - don't load all tools when you have many\n5. **Monitor and iterate** - track selection patterns to improve over time"
}
