{
  "title": "Memory & Context Patterns",
  "objectives": [
    "Distinguish between short-term and long-term memory",
    "Master the four memory scope levels",
    "Implement common memory patterns for production agents"
  ],
  "content": "# Memory & Context Patterns\n\nWithout memory, every conversation starts from scratch. This lesson covers how to give your agents the ability to remember - and when to use different memory strategies.\n\n## Why Memory Matters\n\nConsider this conversation:\n\n```\nSession 1:\nUser: My name is Alice.\nAgent: Nice to meet you, Alice!\n\nSession 2 (next day):\nUser: What's my name?\nAgent: I don't know your name. (FAIL)\n```\n\nWith proper memory:\n\n```\nSession 2 (next day):\nUser: What's my name?\nAgent: Your name is Alice! (SUCCESS)\n```\n\nMemory enables personalization, continuity, and learning.\n\n## Types of Memory\n\n### Short-Term Memory\n\nContext within a single conversation:\n- Current conversation history\n- Recently mentioned entities\n- Temporary working state\n\n**Managed by:** Agent framework (Strands, LangGraph, etc.)\n\n**Lifetime:** Single session\n\n### Long-Term Memory\n\nPersistent knowledge across sessions:\n- User preferences and facts\n- Past interaction summaries\n- Learned behaviors\n- Shared knowledge between agents\n\n**Managed by:** AgentCore Memory service\n\n**Lifetime:** Days, weeks, months, or indefinitely\n\n## Memory Architecture\n\n```\n┌─────────────────────────────────────────────────────────┐\n│                    AgentCore Memory                      │\n│                                                          │\n│  ┌────────────────────────────────────────────────────┐ │\n│  │              Memory Store                           │ │\n│  │                                                     │ │\n│  │  ┌─────────────┐  ┌─────────────┐                  │ │\n│  │  │  User A's   │  │  User B's   │  ...             │ │\n│  │  │  Memories   │  │  Memories   │                  │ │\n│  │  └─────────────┘  └─────────────┘                  │ │\n│  │                                                     │ │\n│  │  ┌─────────────────────────────────────────────┐  │ │\n│  │  │         Shared Knowledge Base               │  │ │\n│  │  │  (Available to all agents)                  │  │ │\n│  │  └─────────────────────────────────────────────┘  │ │\n│  └────────────────────────────────────────────────────┘ │\n│                                                          │\n│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐ │\n│  │   Store     │  │  Retrieve   │  │    Semantic     │ │\n│  │   API       │  │   API       │  │    Search       │ │\n│  └─────────────┘  └─────────────┘  └─────────────────┘ │\n└─────────────────────────────────────────────────────────┘\n```\n\n## The Four Memory Scopes\n\n### 1. User-Scoped Memory\n\nPrivate to a single user across all sessions:\n- Personal preferences\n- User facts (name, timezone, etc.)\n- Conversation history\n\n```python\n# Store user preferences\nmemory.store(\n    namespace=\"user_preferences\",\n    key=\"user_123\",\n    content={\n        \"name\": \"Alice\",\n        \"timezone\": \"America/New_York\",\n        \"communication_style\": \"concise\"\n    }\n)\n```\n\n### 2. Session-Scoped Memory\n\nTied to a single conversation session:\n- Current conversation context\n- Temporary working state\n- Cleared when session ends\n\n```python\n# Store session-specific context\nmemory.store(\n    namespace=\"session_context\",\n    key=session_id,\n    content={\n        \"topic\": \"order_inquiry\",\n        \"order_id\": \"12345\",\n        \"resolved\": False\n    },\n    ttl=3600  # Expires in 1 hour\n)\n```\n\n### 3. Agent-Scoped Memory\n\nShared across all instances of an agent:\n- Learned patterns\n- Agent configuration\n- Agent-specific knowledge base\n\n```python\n# Store agent-level knowledge\nmemory.store(\n    namespace=\"agent_knowledge\",\n    key=\"order_agent\",\n    content={\n        \"escalation_threshold\": 3,\n        \"common_issues\": [\"shipping_delay\", \"wrong_item\"],\n        \"response_templates\": {...}\n    }\n)\n```\n\n### 4. Global Memory\n\nAvailable across all agents and users:\n- Company policies\n- Product information\n- Shared knowledge base\n\n```python\n# Store company-wide knowledge\nmemory.store(\n    namespace=\"company_knowledge\",\n    key=\"return_policy\",\n    content=\"Returns accepted within 30 days with receipt...\"\n)\n\n# Any agent can access\npolicy = memory.retrieve(\"company_knowledge\", \"return_policy\")\n```\n\n## Core Memory Operations\n\n### Store\n\n```python\nfrom bedrock_agentcore.memory import MemoryClient\n\nmemory = MemoryClient()\n\nmemory.store(\n    namespace=\"user_facts\",\n    key=\"user_123\",\n    content={\n        \"name\": \"Alice\",\n        \"preferences\": [\"dark mode\", \"concise responses\"],\n        \"timezone\": \"America/New_York\"\n    }\n)\n```\n\n### Retrieve\n\n```python\n# Get specific memory by key\nuser_facts = memory.retrieve(\n    namespace=\"user_facts\",\n    key=\"user_123\"\n)\n\n# Semantic search for relevant memories\nrelevant = memory.search(\n    query=\"What does Alice prefer?\",\n    namespace=\"user_facts\",\n    limit=5\n)\n```\n\n### Update\n\n```python\n# Append to existing memory\nmemory.append(\n    namespace=\"conversation_summary\",\n    key=\"user_123\",\n    content=\"User asked about order status on Jan 1\"\n)\n\n# Replace memory entirely\nmemory.update(\n    namespace=\"user_facts\",\n    key=\"user_123\",\n    content=updated_facts\n)\n```\n\n### Delete\n\n```python\n# Remove specific memory\nmemory.delete(\n    namespace=\"user_facts\",\n    key=\"user_123\"\n)\n\n# Clear all memories for a user (GDPR compliance)\nmemory.clear(namespace=\"*\", key_prefix=\"user_123\")\n```\n\n## Common Memory Patterns\n\n### Pattern 1: User Profile\n\nStore and retrieve user information for personalization:\n\n```python\ndef save_user_profile(user_id, profile):\n    memory.store(\n        namespace=\"profiles\",\n        key=user_id,\n        content=profile\n    )\n\ndef get_user_profile(user_id):\n    return memory.retrieve(\n        namespace=\"profiles\",\n        key=user_id\n    )\n\n# Usage in agent\nprofile = get_user_profile(user_id)\nif profile:\n    greeting = f\"Hello {profile['name']}!\"\nelse:\n    greeting = \"Hello there!\"\n```\n\n### Pattern 2: Conversation Summary\n\nKeep summarized context from past conversations:\n\n```python\ndef update_conversation_summary(user_id, new_summary):\n    existing = memory.retrieve(\"summaries\", user_id) or \"\"\n    combined = f\"{existing}\\n{new_summary}\"\n    \n    # Keep only recent summaries to manage size\n    memory.store(\"summaries\", user_id, combined[-10000:])\n\ndef get_conversation_context(user_id):\n    return memory.retrieve(\"summaries\", user_id) or \"\"\n```\n\n### Pattern 3: Shared Knowledge\n\nMake knowledge available to all agents:\n\n```python\n# Store once (admin operation)\nmemory.store(\n    namespace=\"company_knowledge\",\n    key=\"shipping_policy\",\n    content=\"\"\"Standard shipping: 5-7 business days.\n    Express shipping: 2-3 business days.\n    Free shipping on orders over $50.\"\"\"\n)\n\n# Any agent can access\ndef get_shipping_info():\n    return memory.retrieve(\"company_knowledge\", \"shipping_policy\")\n```\n\n### Pattern 4: Learning from Success\n\nImprove agent behavior over time:\n\n```python\ndef log_successful_interaction(query, response, feedback):\n    if feedback == \"positive\":\n        memory.store(\n            namespace=\"successful_responses\",\n            key=hash(query),\n            content={\"query\": query, \"response\": response}\n        )\n\ndef find_similar_success(query):\n    return memory.search(\n        query=query,\n        namespace=\"successful_responses\",\n        limit=3\n    )\n```\n\n## Integrating Memory with Your Agent\n\n### With Strands Agents\n\n```python\nfrom strands import Agent\nfrom bedrock_agentcore.memory import MemoryClient\n\nmemory = MemoryClient()\n\n# Memory automatically integrated\nagent = Agent(memory=memory)\n```\n\n### Manual Integration\n\n```python\n@app.entrypoint\ndef invoke(payload):\n    user_id = payload.get(\"user_id\", \"default\")\n    user_message = payload.get(\"prompt\", \"Hello!\")\n    \n    # Retrieve conversation history\n    history = memory.retrieve(\"conversations\", user_id) or []\n    \n    # Add context to the agent\n    context = \"\\n\".join([f\"{m['role']}: {m['content']}\" for m in history[-5:]])\n    \n    # Run agent with context\n    result = agent(f\"Previous conversation:\\n{context}\\n\\nUser: {user_message}\")\n    \n    # Store updated history\n    history.append({\"role\": \"user\", \"content\": user_message})\n    history.append({\"role\": \"assistant\", \"content\": result.message})\n    memory.store(\"conversations\", user_id, history)\n    \n    return {\"result\": result.message}\n```\n\n## Best Practices\n\n### 1. Structure Your Namespaces\n\n```python\n# Good: Clear hierarchy\n\"users/{user_id}/preferences\"\n\"users/{user_id}/history\"\n\"knowledge/products\"\n\"knowledge/policies\"\n\n# Avoid: Flat, unclear\n\"data1\"\n\"stuff\"\n```\n\n### 2. Handle Missing Memory Gracefully\n\n```python\ndef get_user_name(user_id):\n    profile = memory.retrieve(\"profiles\", user_id)\n    if profile and \"name\" in profile:\n        return profile[\"name\"]\n    return \"there\"  # Graceful default\n```\n\n### 3. Manage Memory Size\n\n- Summarize long conversations instead of storing everything\n- Set TTL (time-to-live) for temporary data\n- Periodically clean up obsolete data\n\n### 4. Privacy Considerations\n\n- Don't store sensitive data unnecessarily\n- Implement data retention policies\n- Allow users to request deletion (GDPR, CCPA)\n- Encrypt sensitive information\n\n## Key Takeaways\n\n1. **Short-term vs long-term** - Use the right type for your use case\n2. **Four scopes** - User, Session, Agent, Global\n3. **Core operations** - Store, Retrieve, Update, Delete\n4. **Common patterns** - User Profile, Conversation Summary, Shared Knowledge, Learning\n5. **Handle gracefully** - Always have defaults for missing memory"
}
