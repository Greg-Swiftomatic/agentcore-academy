{
  "title": "Building Custom Tools",
  "objectives": [
    "Create custom tools using the @tool decorator",
    "Design tool interfaces with proper types and documentation",
    "Handle errors and edge cases in tool implementations"
  ],
  "content": "# Building Custom Tools\n\nTools are what give agents their superpowers. While agents can reason and communicate, tools let them take action - query databases, call APIs, send emails, or anything else your application needs.\n\n## What is a Tool?\n\nA tool is a function that an agent can call to perform an action. The agent:\n1. Decides when to use the tool (based on user intent)\n2. Extracts the right parameters from the conversation\n3. Calls the tool and uses the result in its response\n\n```\nUser: \"What time is it in Tokyo?\"\n           │\n           ▼\n    Agent decides to use get_time tool\n           │\n           ▼\n    get_time(timezone=\"Asia/Tokyo\")\n           │\n           ▼\n    Returns: \"2026-01-01 19:00:00\"\n           │\n           ▼\n    Agent: \"It's 7:00 PM in Tokyo.\"\n```\n\n## Creating Your First Tool\n\n### The @tool Decorator\n\nThe simplest way to create a tool is with the `@tool` decorator:\n\n```python\nfrom strands import Agent, tool\n\n@tool\ndef get_current_time() -> str:\n    \"\"\"Get the current date and time.\"\"\"\n    from datetime import datetime\n    return datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n# Use it with an agent\nagent = Agent(tools=[get_current_time])\nresponse = agent(\"What time is it?\")\n```\n\nThe decorator:\n- Registers the function as a tool\n- Uses the function name as the tool name\n- Uses the docstring as the tool description\n- Infers parameters from the function signature\n\n## Tool Anatomy: The Essential Parts\n\n### 1. Name\n\nThe tool name comes from the function name. Use clear, action-oriented names:\n\n```python\n# Good names\n@tool\ndef get_order_status(): ...\n\n@tool\ndef send_email(): ...\n\n@tool\ndef calculate_shipping_cost(): ...\n\n# Bad names\n@tool\ndef do_thing(): ...  # Too vague\n\n@tool\ndef x(): ...  # Not descriptive\n```\n\n### 2. Description\n\nThe docstring is critical - it tells the agent when to use this tool:\n\n```python\n@tool\ndef get_order_status(order_id: str) -> dict:\n    \"\"\"Get the current fulfillment status of a customer order.\n    \n    Returns shipping status, tracking number, estimated delivery date,\n    and list of items in the order. Use this when customers ask about\n    where their order is, when it will arrive, or what's in their order.\n    \"\"\"\n    return order_service.get_status(order_id)\n```\n\n### 3. Parameters\n\nDefine what inputs the tool needs using type hints:\n\n```python\n@tool\ndef search_products(\n    query: str,\n    category: str = None,\n    max_price: float = None,\n    in_stock_only: bool = True\n) -> list:\n    \"\"\"Search the product catalog.\n    \n    Args:\n        query: Search terms (required)\n        category: Optional category filter (e.g., \"electronics\", \"clothing\")\n        max_price: Maximum price filter\n        in_stock_only: If True, only return products currently in stock\n    \"\"\"\n    return catalog.search(\n        query=query,\n        category=category,\n        max_price=max_price,\n        in_stock_only=in_stock_only\n    )\n```\n\n### 4. Return Value\n\nReturn structured data the agent can use:\n\n```python\n@tool\ndef get_weather(location: str) -> dict:\n    \"\"\"Get current weather for a location.\"\"\"\n    return {\n        \"location\": location,\n        \"temperature\": 72,\n        \"unit\": \"fahrenheit\",\n        \"conditions\": \"sunny\",\n        \"humidity\": 45\n    }\n```\n\n## Complete Tool Examples\n\n### Example 1: Calculator Tool\n\n```python\n@tool\ndef calculate(expression: str) -> float:\n    \"\"\"Evaluate a mathematical expression.\n    \n    Args:\n        expression: A math expression like \"2 + 2\" or \"sqrt(16)\"\n        \n    Returns:\n        The result of the calculation\n    \"\"\"\n    import math\n    # Safe evaluation - only allow math functions\n    allowed = {k: v for k, v in math.__dict__.items() if not k.startswith(\"_\")}\n    return eval(expression, {\"__builtins__\": {}}, allowed)\n```\n\n### Example 2: API Integration Tool\n\n```python\nimport httpx\n\n@tool\ndef get_stock_price(symbol: str) -> dict:\n    \"\"\"Get the current stock price for a ticker symbol.\n    \n    Args:\n        symbol: Stock ticker symbol (e.g., \"AAPL\", \"GOOGL\")\n        \n    Returns:\n        Current price, daily change, and volume\n    \"\"\"\n    response = httpx.get(\n        f\"https://api.example.com/stocks/{symbol}\",\n        headers={\"Authorization\": f\"Bearer {API_KEY}\"}\n    )\n    response.raise_for_status()\n    return response.json()\n```\n\n### Example 3: Database Query Tool\n\n```python\n@tool\ndef search_customers(\n    query: str,\n    limit: int = 10\n) -> list:\n    \"\"\"Search for customers by name or email.\n    \n    Args:\n        query: Search term to match against name or email\n        limit: Maximum number of results (default 10)\n        \n    Returns:\n        List of matching customers with id, name, and email\n    \"\"\"\n    results = db.execute(\n        \"SELECT id, name, email FROM customers \"\n        \"WHERE name ILIKE %s OR email ILIKE %s \"\n        \"LIMIT %s\",\n        (f\"%{query}%\", f\"%{query}%\", limit)\n    )\n    return [{\"id\": r[0], \"name\": r[1], \"email\": r[2]} for r in results]\n```\n\n## Error Handling\n\n### Return Errors as Data\n\nDon't raise exceptions - return error information the agent can explain:\n\n```python\n@tool\ndef get_order_status(order_id: str) -> dict:\n    \"\"\"Get order status by ID.\"\"\"\n    try:\n        order = order_service.get(order_id)\n        if not order:\n            return {\n                \"error\": \"not_found\",\n                \"message\": f\"No order found with ID {order_id}\"\n            }\n        return {\n            \"order_id\": order.id,\n            \"status\": order.status,\n            \"tracking_number\": order.tracking_number\n        }\n    except Exception as e:\n        return {\n            \"error\": \"internal_error\",\n            \"message\": \"Unable to retrieve order status. Please try again.\"\n        }\n```\n\n### Validate Input\n\n```python\n@tool\ndef send_email(to: str, subject: str, body: str) -> dict:\n    \"\"\"Send an email to a customer.\"\"\"\n    # Validate email format\n    if not re.match(r\"^[\\w.-]+@[\\w.-]+\\.\\w+$\", to):\n        return {\n            \"success\": False,\n            \"error\": f\"Invalid email address: {to}\"\n        }\n    \n    # Validate content length\n    if len(subject) > 200:\n        return {\n            \"success\": False,\n            \"error\": \"Subject line too long (max 200 characters)\"\n        }\n    \n    # Send the email\n    email_service.send(to=to, subject=subject, body=body)\n    return {\"success\": True, \"message\": f\"Email sent to {to}\"}\n```\n\n## Async Tools\n\nFor I/O-bound operations, use async:\n\n```python\n@tool\nasync def fetch_url(url: str) -> dict:\n    \"\"\"Fetch content from a URL.\"\"\"\n    async with httpx.AsyncClient() as client:\n        response = await client.get(url)\n        return {\n            \"status_code\": response.status_code,\n            \"content_type\": response.headers.get(\"content-type\"),\n            \"body\": response.text[:1000]  # First 1000 chars\n        }\n```\n\n## Registering Tools with Gateway\n\nFor centralized tool management, register tools with Gateway:\n\n```python\nfrom bedrock_agentcore.gateway import GatewayClient\n\ngateway = GatewayClient()\n\n# Register a tool\ngateway.register_tool(\n    name=\"get_order_status\",\n    description=\"Get order fulfillment status, tracking, and delivery estimate\",\n    parameters={\n        \"order_id\": {\n            \"type\": \"string\",\n            \"required\": True,\n            \"description\": \"The order identifier\"\n        }\n    },\n    handler=get_order_status  # Your function\n)\n\n# Agents can discover and use registered tools\ntools = gateway.get_tools()\nagent = Agent(tools=tools)\n```\n\n## Lambda-Backed Tools\n\nFor complex tools or those needing separate scaling:\n\n```python\nfrom bedrock_agentcore.tools import LambdaTool\n\n# Tool backed by a Lambda function\norder_tool = LambdaTool(\n    name=\"get_order_status\",\n    description=\"Get order status from the order management system\",\n    function_arn=\"arn:aws:lambda:us-east-1:123456789:function:order-status\",\n    parameters={\n        \"order_id\": {\"type\": \"string\", \"required\": True}\n    }\n)\n\nagent = Agent(tools=[order_tool])\n```\n\n## Organizing Tools\n\nFor larger projects, organize tools by domain:\n\n```\nmy-agent/\n├── agent/\n│   ├── main.py\n│   └── tools/\n│       ├── __init__.py\n│       ├── orders.py      # Order-related tools\n│       ├── products.py    # Product-related tools\n│       └── customers.py   # Customer-related tools\n```\n\n```python\n# tools/orders.py\nfrom strands import tool\n\n@tool\ndef get_order_status(order_id: str) -> dict:\n    \"\"\"Get order status.\"\"\"\n    ...\n\n@tool\ndef cancel_order(order_id: str, reason: str) -> dict:\n    \"\"\"Cancel an order.\"\"\"\n    ...\n\n@tool\ndef update_shipping_address(order_id: str, address: dict) -> dict:\n    \"\"\"Update the shipping address for an order.\"\"\"\n    ...\n```\n\n```python\n# main.py\nfrom tools.orders import get_order_status, cancel_order, update_shipping_address\nfrom tools.products import search_products, get_product_details\n\nagent = Agent(tools=[\n    get_order_status,\n    cancel_order,\n    update_shipping_address,\n    search_products,\n    get_product_details\n])\n```\n\n## Best Practices\n\n### 1. Single Responsibility\n\nEach tool should do one thing well:\n\n```python\n# Good: Focused tools\n@tool\ndef get_order_status(order_id: str): ...\n\n@tool\ndef cancel_order(order_id: str): ...\n\n# Bad: Tool that does too much\n@tool\ndef manage_order(order_id: str, action: str): ...  # What actions? Unclear.\n```\n\n### 2. Descriptive Parameters\n\nAlways document what each parameter means:\n\n```python\n@tool\ndef schedule_meeting(\n    title: str,\n    attendees: list,\n    duration_minutes: int = 30,\n    timezone: str = \"UTC\"\n) -> dict:\n    \"\"\"Schedule a meeting.\n    \n    Args:\n        title: Meeting title/subject\n        attendees: List of email addresses to invite\n        duration_minutes: Meeting length in minutes (default: 30)\n        timezone: Timezone for the meeting time (default: UTC)\n    \"\"\"\n    ...\n```\n\n### 3. Return Structured Data\n\nReturn dictionaries that the agent can easily interpret:\n\n```python\n# Good: Structured response\nreturn {\n    \"success\": True,\n    \"order_id\": \"12345\",\n    \"status\": \"shipped\",\n    \"tracking_url\": \"https://...\"\n}\n\n# Bad: Just a string\nreturn \"Order 12345 shipped\"\n```\n\n### 4. Handle All Edge Cases\n\n```python\n@tool\ndef get_user_profile(user_id: str) -> dict:\n    \"\"\"Get user profile information.\"\"\"\n    if not user_id:\n        return {\"error\": \"user_id is required\"}\n    \n    user = db.get_user(user_id)\n    if not user:\n        return {\"error\": \"not_found\", \"message\": f\"User {user_id} not found\"}\n    \n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"email\": user.email\n    }\n```\n\n## Key Takeaways\n\n1. **Use @tool decorator** - simplest way to create tools\n2. **Write clear docstrings** - they determine when the tool is used\n3. **Type your parameters** - helps the agent extract the right values\n4. **Return structured data** - dictionaries over strings\n5. **Handle errors gracefully** - return error info, don't raise exceptions\n6. **Single responsibility** - one tool, one job"
}
